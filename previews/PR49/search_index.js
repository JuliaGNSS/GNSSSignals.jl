var documenterSearchIndex = {"docs":
[{"location":"api/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"api/#GNSS-System-Types","page":"API Reference","title":"GNSS System Types","text":"","category":"section"},{"location":"api/#Modulation-Types","page":"API Reference","title":"Modulation Types","text":"","category":"section"},{"location":"api/#Code-Generation","page":"API Reference","title":"Code Generation","text":"","category":"section"},{"location":"api/#Code-Access","page":"API Reference","title":"Code Access","text":"","category":"section"},{"location":"api/#System-Properties","page":"API Reference","title":"System Properties","text":"","category":"section"},{"location":"api/#Spectrum-Functions","page":"API Reference","title":"Spectrum Functions","text":"","category":"section"},{"location":"api/#Utility-Functions","page":"API Reference","title":"Utility Functions","text":"","category":"section"},{"location":"api/#GNSSSignals.AbstractGNSS","page":"API Reference","title":"GNSSSignals.AbstractGNSS","text":"AbstractGNSS{C}\n\nAbstract supertype for all GNSS system types.\n\nConcrete subtypes include GPSL1, GPSL5, and GalileoE1B. The type parameter C represents the code matrix type.\n\n\n\n\n\n","category":"type"},{"location":"api/#GNSSSignals.GPSL1","page":"API Reference","title":"GNSSSignals.GPSL1","text":"GPSL1{C} <: AbstractGNSS{C}\n\nGPS L1 C/A signal type.\n\nGPS L1 uses BPSK (LOC) modulation with a 1023-chip C/A code at 1.023 Mcps, transmitted on the L1 carrier frequency of 1575.42 MHz.\n\nExample\n\ngpsl1 = GPSL1()\nget_code_length(gpsl1)  # 1023\n\n\n\n\n\n","category":"type"},{"location":"api/#GNSSSignals.GPSL5","page":"API Reference","title":"GNSSSignals.GPSL5","text":"GPSL5{C} <: AbstractGNSS{C}\n\nGPS L5 signal type.\n\nGPS L5 uses BPSK (LOC) modulation with a 10230-chip code at 10.23 Mcps and a 10-bit Neuman-Hofman secondary code, transmitted on the L5 carrier frequency of 1176.45 MHz.\n\nExample\n\ngpsl5 = GPSL5()\nget_code_length(gpsl5)           # 10230\nget_secondary_code_length(gpsl5) # 10\n\n\n\n\n\n","category":"type"},{"location":"api/#GNSSSignals.GalileoE1B","page":"API Reference","title":"GNSSSignals.GalileoE1B","text":"GalileoE1B{C} <: AbstractGNSS{C}\n\nGalileo E1B signal type.\n\nGalileo E1B uses CBOC(6,1,1/11) modulation with a 4092 chip code at 1.023 Mcps, transmitted on the E1 carrier frequency of 1575.42 MHz.\n\n\n\n\n\n","category":"type"},{"location":"api/#GNSSSignals.LOC","page":"API Reference","title":"GNSSSignals.LOC","text":"LOC()\n\nLegacy/BPSK modulation (no subcarrier).\n\nUsed for GPS L1 C/A and GPS L5 signals.\n\n\n\n\n\n","category":"type"},{"location":"api/#GNSSSignals.BOCsin","page":"API Reference","title":"GNSSSignals.BOCsin","text":"BOCsin(m, n)\n\nSine-phased Binary Offset Carrier modulation.\n\nBOC(m,n) uses a subcarrier frequency of m * 1.023 MHz and a code rate of n * 1.023 Mcps.\n\nArguments\n\nm: Subcarrier frequency multiplier (must be ≥ 1)\nn: Code rate multiplier (must be ≥ 1)\n\nExample\n\nboc11 = BOCsin(1, 1)  # BOC(1,1)\n\n\n\n\n\n","category":"type"},{"location":"api/#GNSSSignals.BOCcos","page":"API Reference","title":"GNSSSignals.BOCcos","text":"BOCcos(m, n)\n\nCosine-phased Binary Offset Carrier modulation.\n\nBOC(m,n) uses a subcarrier frequency of m * 1.023 MHz and a code rate of n * 1.023 Mcps.\n\nArguments\n\nm: Subcarrier frequency multiplier (must be ≥ 1)\nn: Code rate multiplier (must be ≥ 1)\n\nExample\n\nboc11 = BOCcos(1, 1)  # BOC(1,1) with cosine phase\n\n\n\n\n\n","category":"type"},{"location":"api/#GNSSSignals.CBOC","page":"API Reference","title":"GNSSSignals.CBOC","text":"CBOC(boc1, boc2, boc1_power)\n\nComposite Binary Offset Carrier modulation.\n\nCBOC combines two BOC modulations with specified power distribution. Used for Galileo E1B signals as CBOC(6,1,1/11).\n\nArguments\n\nboc1: First BOC component\nboc2: Second BOC component\nboc1_power: Power fraction allocated to first BOC (0 < power < 1)\n\nExample\n\ncboc = CBOC(BOCsin(1, 1), BOCsin(6, 1), 10/11)  # CBOC(6,1,1/11)\n\n\n\n\n\n","category":"type"},{"location":"api/#GNSSSignals.gen_code","page":"API Reference","title":"GNSSSignals.gen_code","text":"gen_code(num_samples, gnss, prn, sampling_frequency)\ngen_code(\n    num_samples,\n    gnss,\n    prn,\n    sampling_frequency,\n    code_frequency\n)\ngen_code(\n    num_samples,\n    gnss,\n    prn,\n    sampling_frequency,\n    code_frequency,\n    start_phase\n)\ngen_code(\n    num_samples,\n    gnss,\n    prn,\n    sampling_frequency,\n    code_frequency,\n    start_phase,\n    start_index\n)\n\n\nGenerate a sampled code signal for a given PRN.\n\nAllocates and returns a new buffer containing the spreading code sampled at the specified sampling frequency. For in-place operation, use gen_code!.\n\nArguments\n\nnum_samples: Number of samples to generate\ngnss: GNSS system instance (e.g., GPSL1(), GPSL5(), GalileoE1B())\nprn: PRN number of the satellite\nsampling_frequency: Sampling frequency (must be larger than code frequency)\ncode_frequency: Code chipping rate (default: system's nominal code frequency)\nstart_phase: Initial code phase in chips (default: 0.0)\nstart_index: Index offset (default: 0)\n\nReturns\n\nVector: Sampled code signal\n\nExamples\n\njulia> using Unitful: MHz\njulia> sampled_code = gen_code(4000, GPSL1(), 1, 4MHz)\njulia> length(sampled_code)\n4000\n\n\n\n\n\n","category":"function"},{"location":"api/#GNSSSignals.gen_code!","page":"API Reference","title":"GNSSSignals.gen_code!","text":"gen_code!(sampled_code, gnss, prn, sampling_frequency)\ngen_code!(\n    sampled_code,\n    gnss,\n    prn,\n    sampling_frequency,\n    code_frequency\n)\ngen_code!(\n    sampled_code,\n    gnss,\n    prn,\n    sampling_frequency,\n    code_frequency,\n    start_phase\n)\ngen_code!(\n    sampled_code,\n    gnss,\n    prn,\n    sampling_frequency,\n    code_frequency,\n    start_phase,\n    start_index_shift\n)\ngen_code!(\n    sampled_code,\n    gnss,\n    prn,\n    sampling_frequency,\n    code_frequency,\n    start_phase,\n    start_index_shift,\n    maximum_expected_sampling_frequency\n)\ngen_code!(\n    sampled_code,\n    gnss,\n    prn,\n    sampling_frequency,\n    code_frequency,\n    start_phase,\n    start_index_shift,\n    maximum_expected_sampling_frequency,\n    maximum_expected_doppler\n)\ngen_code!(\n    sampled_code,\n    gnss,\n    prn,\n    sampling_frequency,\n    code_frequency,\n    start_phase,\n    start_index_shift,\n    maximum_expected_sampling_frequency,\n    maximum_expected_doppler,\n    PHASET\n)\n\n\nGenerate the code signal in-place for a given PRN.\n\nThis is a highly optimized function for generating sampled spreading codes at arbitrary sampling rates. It uses fixed-point arithmetic and minimizes memory access by exploiting the fact that consecutive samples often map to the same code chip. The algorithm avoids per-sample floating-point operations and modulo calculations, making it suitable for real-time GNSS signal processing applications.\n\nSamples the spreading code at the specified sampling frequency and stores the result in the provided buffer. Includes subcarrier modulation for BOC-type signals.\n\nArguments\n\nsampled_code: Pre-allocated output buffer\ngnss: GNSS system instance (e.g., GPSL1(), GPSL5(), GalileoE1B())\nprn: PRN number of the satellite\nsampling_frequency: Sampling frequency (must be larger than code frequency)\ncode_frequency: Code chipping rate (default: system's nominal code frequency)\nstart_phase: Initial code phase in chips (default: 0.0)\nstart_index_shift: Index offset for the output buffer (default: 0)\nmaximum_expected_sampling_frequency: Maximum expected sampling frequency for optimization\nmaximum_expected_doppler: Maximum expected Doppler frequency (default: 8000 Hz)\nPHASET: Integer type for phase calculations (default: Int32)\n\nReturns\n\nThe modified sampled_code buffer\n\nExamples\n\njulia> using Unitful: MHz\njulia> buffer = zeros(Int16, 4000)\njulia> gen_code!(buffer, GPSL1(), 1, 4MHz)\n\n\n\n\n\n","category":"function"},{"location":"api/#GNSSSignals.get_code","page":"API Reference","title":"GNSSSignals.get_code","text":"get_code(system, phase, prn)\n\n\nGet the code value at a given phase for a specific PRN.\n\nReturns the spreading code value (including subcarrier modulation for BOC signals) at the specified code phase. The phase is automatically wrapped to the code length.\n\nArguments\n\nsystem: A GNSS system instance (e.g., GPSL1(), GPSL5(), GalileoE1B())\nphase: Code phase in chips\nprn: PRN number of the satellite\n\nReturns\n\nCode value (typically Int8 for BPSK, Float32 for CBOC)\n\nExamples\n\njulia> get_code(GPSL1(), 0.0, 1)\n1\njulia> get_code(GPSL1(), 1200.3, 1)\n-1\njulia> get_code.(GPSL1(), 0:1022, 1)  # Full code period\n\n\n\n\n\nget_code(modulation, system, phase, prn)\n\n\nGet code value for BOC-modulated signals at a given phase.\n\nInternal method that handles BOC modulation (sine or cosine phased).\n\n\n\n\n\nget_code(modulation, system, phase, prn)\n\n\nGet code value for LOC (BPSK) signals at a given phase.\n\nInternal method that handles legacy/BPSK modulation without subcarrier.\n\n\n\n\n\n","category":"function"},{"location":"api/#GNSSSignals.get_code_unsafe","page":"API Reference","title":"GNSSSignals.get_code_unsafe","text":"get_code_unsafe(system, phase, prn)\n\n\nGet the code value at a given phase without bounds checking.\n\nThis is a faster version of get_code that skips the modulo operation. The phase must be within [0, code_length * secondary_code_length).\n\nwarning: Warning\nUsing phases outside the valid range results in undefined behavior.\n\nArguments\n\nsystem: A GNSS system instance\nphase: Code phase in chips (must be within valid range)\nprn: PRN number of the satellite\n\nReturns\n\nCode value at the given phase\n\nExamples\n\njulia> get_code_unsafe(GPSL1(), 500.0, 1)\n\n\n\n\n\nget_code_unsafe(modulation, system, phase, prn)\n\n\nGet code value for BOC signals without bounds checking.\n\nInternal method for BOC modulation without phase wrapping.\n\n\n\n\n\nget_code_unsafe(modulation, system, phase, prn)\n\n\nGet code value for LOC (BPSK) signals without bounds checking.\n\nInternal method for BPSK modulation without phase wrapping.\n\n\n\n\n\n","category":"function"},{"location":"api/#GNSSSignals.get_codes","page":"API Reference","title":"GNSSSignals.get_codes","text":"get_codes(gnss)\n\n\nGet the full code matrix for a GNSS system.\n\nReturns the codes as a matrix where each column represents a PRN.\n\nArguments\n\ngnss: A GNSS system instance (e.g., GPSL1(), GPSL5(), GalileoE1B())\n\nReturns\n\nMatrix: Code matrix of size (code_length, num_prns)\n\nExamples\n\njulia> codes = get_codes(GPSL1())\njulia> size(codes)\n(1023, 37)\n\n\n\n\n\n","category":"function"},{"location":"api/#GNSSSignals.get_code_length","page":"API Reference","title":"GNSSSignals.get_code_length","text":"get_code_length(gpsl1)\n\n\nGet the code length for GPS L1.\n\nReturns\n\nInt: 1023 chips\n\nExamples\n\njulia> get_code_length(GPSL1())\n1023\n\n\n\n\n\nget_code_length(gpsl5)\n\n\nGet the code length for GPS L5.\n\nReturns\n\nInt: 10230 chips\n\nExamples\n\njulia> get_code_length(GPSL5())\n10230\n\n\n\n\n\nget_code_length(galileo_e1b)\n\n\nGet the code length for Galileo E1B.\n\nReturns\n\nInt: 4092 chips\n\nExamples\n\njulia> get_code_length(GalileoE1B())\n4092\n\n\n\n\n\n","category":"function"},{"location":"api/#GNSSSignals.get_secondary_code_length","page":"API Reference","title":"GNSSSignals.get_secondary_code_length","text":"get_secondary_code_length(gnss)\n\n\nGet the length of the secondary code.\n\nArguments\n\ngnss: A GNSS system instance\n\nReturns\n\nInt: Secondary code length (1 if no secondary code)\n\nExamples\n\njulia> get_secondary_code_length(GPSL1())\n1\njulia> get_secondary_code_length(GPSL5())\n10\n\n\n\n\n\n","category":"function"},{"location":"api/#GNSSSignals.get_secondary_code","page":"API Reference","title":"GNSSSignals.get_secondary_code","text":"get_secondary_code(gpsl1)\n\n\nGet the secondary code for GPS L1.\n\nGPS L1 has no secondary code, so this returns 1.\n\nReturns\n\nInt: 1 (no secondary code)\n\nExamples\n\njulia> get_secondary_code(GPSL1())\n1\n\n\n\n\n\nget_secondary_code(galileo_e1b)\n\n\nGet the secondary code for Galileo E1B.\n\nGalileo E1B has no secondary code, so this returns 1.\n\nReturns\n\nInt: 1 (no secondary code)\n\nExamples\n\njulia> get_secondary_code(GalileoE1B())\n1\n\n\n\n\n\nget_secondary_code(gnss, phase)\n\n\nGet the secondary code value at a given phase.\n\nArguments\n\ngnss: A GNSS system instance\nphase: Code phase in chips\n\nReturns\n\nSecondary code value at the given phase\n\nExamples\n\njulia> get_secondary_code(GPSL5(), 10230.0)  # Start of second code period\n1\n\n\n\n\n\nget_secondary_code(gnss, code, phase)\n\n\nGet secondary code value when code is a single integer (no secondary code).\n\nReturns the code value unchanged.\n\n\n\n\n\nget_secondary_code(gnss, code, phase)\n\n\nGet secondary code value at phase when code is a tuple (has secondary code).\n\nComputes the secondary code index from the phase and returns the corresponding value.\n\n\n\n\n\n","category":"function"},{"location":"api/#GNSSSignals.get_center_frequency","page":"API Reference","title":"GNSSSignals.get_center_frequency","text":"get_center_frequency(gpsl1)\n\n\nGet the center (carrier) frequency for GPS L1.\n\nReturns\n\nFrequency: 1575.42 MHz\n\nExamples\n\njulia> get_center_frequency(GPSL1())\n1575420000 Hz\n\n\n\n\n\nget_center_frequency(gpsl5)\n\n\nGet the center (carrier) frequency for GPS L5.\n\nReturns\n\nFrequency: 1176.45 MHz\n\nExamples\n\njulia> get_center_frequency(GPSL5())\n1176450000 Hz\n\n\n\n\n\nget_center_frequency(galileo_e1b)\n\n\nGet the center (carrier) frequency for Galileo E1B.\n\nReturns\n\nFrequency: 1575.42 MHz\n\nExamples\n\njulia> get_center_frequency(GalileoE1B())\n1575420000 Hz\n\n\n\n\n\n","category":"function"},{"location":"api/#GNSSSignals.get_code_frequency","page":"API Reference","title":"GNSSSignals.get_code_frequency","text":"get_code_frequency(gpsl1)\n\n\nGet the code chipping rate for GPS L1.\n\nReturns\n\nFrequency: 1.023 MHz\n\nExamples\n\njulia> get_code_frequency(GPSL1())\n1023000 Hz\n\n\n\n\n\nget_code_frequency(gpsl5)\n\n\nGet the code chipping rate for GPS L5.\n\nReturns\n\nFrequency: 10.23 MHz\n\nExamples\n\njulia> get_code_frequency(GPSL5())\n10230000 Hz\n\n\n\n\n\nget_code_frequency(galileo_e1b)\n\n\nGet the code chipping rate for Galileo E1B.\n\nReturns\n\nFrequency: 1.023 MHz\n\nExamples\n\njulia> get_code_frequency(GalileoE1B())\n1023000 Hz\n\n\n\n\n\n","category":"function"},{"location":"api/#GNSSSignals.get_data_frequency","page":"API Reference","title":"GNSSSignals.get_data_frequency","text":"get_data_frequency(gpsl1)\n\n\nGet the data bit rate for GPS L1.\n\nReturns\n\nFrequency: 50 Hz\n\nExamples\n\njulia> get_data_frequency(GPSL1())\n50 Hz\n\n\n\n\n\nget_data_frequency(gpsl5)\n\n\nGet the data bit rate for GPS L5.\n\nReturns\n\nFrequency: 100 Hz\n\nExamples\n\njulia> get_data_frequency(GPSL5())\n100 Hz\n\n\n\n\n\nget_data_frequency(galileo_e1b)\n\n\nGet the data bit rate for Galileo E1B.\n\nReturns\n\nFrequency: 250 Hz\n\nExamples\n\njulia> get_data_frequency(GalileoE1B())\n250 Hz\n\n\n\n\n\n","category":"function"},{"location":"api/#GNSSSignals.get_code_center_frequency_ratio","page":"API Reference","title":"GNSSSignals.get_code_center_frequency_ratio","text":"get_code_center_frequency_ratio(gnss)\n\n\nGet the ratio of code frequency to center frequency.\n\nThis ratio is used to compute the code Doppler from the carrier Doppler.\n\nArguments\n\ngnss: A GNSS system instance\n\nReturns\n\nFloat64: The code-to-center frequency ratio\n\nExamples\n\njulia> get_code_center_frequency_ratio(GPSL1())\n0.0006493506493506494\n\n\n\n\n\n","category":"function"},{"location":"api/#GNSSSignals.get_modulation","page":"API Reference","title":"GNSSSignals.get_modulation","text":"get_modulation(s)\n\n\nGet the modulation type for a GNSS system.\n\nArguments\n\nsystem: A GNSS system instance or type\n\nReturns\n\nModulation: The modulation type (LOC, BOCsin, BOCcos, or CBOC)\n\nExamples\n\njulia> get_modulation(GPSL1())\nLOC()\njulia> get_modulation(GalileoE1B())\nCBOC{BOCsin{Int64, Int64}, BOCsin{Int64, Int64}}(BOCsin{Int64, Int64}(1, 1), BOCsin{Int64, Int64}(6, 1), 0.90909094f0)\n\n\n\n\n\n","category":"function"},{"location":"api/#GNSSSignals.get_system_string","page":"API Reference","title":"GNSSSignals.get_system_string","text":"get_system_string(s)\n\n\nGet the system name as a string.\n\nArguments\n\nsystem: A GNSS system instance\n\nReturns\n\nString: System identifier string\n\nExamples\n\njulia> get_system_string(GPSL1())\n\"GPSL1\"\n\n\n\n\n\n","category":"function"},{"location":"api/#GNSSSignals.min_bits_for_code_length","page":"API Reference","title":"GNSSSignals.min_bits_for_code_length","text":"min_bits_for_code_length(gnss)\n\n\nGet the minimum number of bits needed to represent the code length.\n\nCalculates the number of bits required to represent the full code length, including secondary code if present.\n\nArguments\n\ngnss: A GNSS system instance\n\nReturns\n\nInt: Number of bits needed\n\nExamples\n\njulia> min_bits_for_code_length(GPSL1())\n10\njulia> min_bits_for_code_length(GPSL5())\n17\n\n\n\n\n\n","category":"function"},{"location":"api/#GNSSSignals.get_code_type","page":"API Reference","title":"GNSSSignals.get_code_type","text":"get_code_type(system)\n\n\nGet the element type for code values of a GNSS system.\n\nReturns the numeric type used to represent code values. For BPSK (LOC) signals, this is typically Int16. For CBOC signals, this is a floating-point type.\n\nArguments\n\nsystem: A GNSS system instance\n\nReturns\n\nType: The element type for code values\n\nExamples\n\njulia> get_code_type(GPSL1())\nInt16\njulia> get_code_type(GalileoE1B())\nFloat32\n\n\n\n\n\n","category":"function"},{"location":"api/#GNSSSignals.get_code_spectrum","page":"API Reference","title":"GNSSSignals.get_code_spectrum","text":"get_code_spectrum(system, f)\n\n\nGet the spectral power density of a GNSS signal at a given frequency.\n\nComputes the power spectral density based on the system's modulation type.\n\nArguments\n\nsystem: A GNSS system instance\nf: Baseband frequency at which to evaluate the spectrum\n\nReturns\n\nSpectral power density value\n\nExamples\n\njulia> using Unitful: kHz\njulia> get_code_spectrum(GPSL1(), 0kHz)\n9.775171065493646e-7\n\n\n\n\n\n","category":"function"},{"location":"api/#GNSSSignals.get_code_spectrum_BPSK","page":"API Reference","title":"GNSSSignals.get_code_spectrum_BPSK","text":"get_code_spectrum_BPSK(fc, f)\n\n\nCalculate the spectral power density of a BPSK modulated signal.\n\nComputes the power spectral density at baseband frequency f for a BPSK signal with chip rate fc.\n\nArguments\n\nfc: Code chip rate\nf: Baseband frequency at which to evaluate the spectrum\n\nReturns\n\nSpectral power density value\n\nExamples\n\njulia> using Unitful: MHz, kHz\njulia> get_code_spectrum_BPSK(1.023MHz, 0kHz)\n9.775171065493646e-7\n\n\n\n\n\n","category":"function"},{"location":"api/#GNSSSignals.get_code_spectrum_BOCsin","page":"API Reference","title":"GNSSSignals.get_code_spectrum_BOCsin","text":"get_code_spectrum_BOCsin(fc, fs, f)\n\n\nCalculate the spectral power density of a sine-phased BOC modulated signal.\n\nComputes the power spectral density at baseband frequency f for a BOC(sin) signal with chip rate fc and subcarrier frequency fs.\n\nArguments\n\nfc: Code chip rate\nfs: Subcarrier frequency\nf: Baseband frequency at which to evaluate the spectrum\n\nReturns\n\nSpectral power density value\n\n\n\n\n\n","category":"function"},{"location":"api/#GNSSSignals.get_code_spectrum_BOCcos","page":"API Reference","title":"GNSSSignals.get_code_spectrum_BOCcos","text":"get_code_spectrum_BOCcos(fc, fs, f)\n\n\nCalculate the spectral power density of a cosine-phased BOC modulated signal.\n\nComputes the power spectral density at baseband frequency f for a BOC(cos) signal with chip rate fc and subcarrier frequency fs.\n\nArguments\n\nfc: Code chip rate\nfs: Subcarrier frequency\nf: Baseband frequency at which to evaluate the spectrum\n\nReturns\n\nSpectral power density value\n\n\n\n\n\n","category":"function"},{"location":"api/#GNSSSignals.read_in_codes","page":"API Reference","title":"GNSSSignals.read_in_codes","text":"read_in_codes(type, filename, num_prns, code_length)\n\n\nRead codes from a binary file.\n\nReads codes encoded in the specified type from a file. The code length must be provided by code_length and the number of PRNs by num_prns.\n\nArguments\n\ntype: The data type of the codes (e.g., Int8)\nfilename: Path to the binary file containing the codes\nnum_prns: Number of PRN codes in the file\ncode_length: Length of each code sequence\n\nReturns\n\nMatrix{type}: A matrix of size (code_length, num_prns) containing the codes\n\nExamples\n\njulia> read_in_codes(Int8, \"/data/gpsl1codes.bin\", 32, 1023)\n\n\n\n\n\n","category":"function"},{"location":"usage/#Usage","page":"Usage","title":"Usage","text":"","category":"section"},{"location":"usage/#Generating-Sampled-Code-Signals-(Recommended)","page":"Usage","title":"Generating Sampled Code Signals (Recommended)","text":"For most applications, use gen_code or gen_code! to generate sampled codes. These functions are highly optimized for real-time GNSS signal processing, using fixed-point arithmetic and minimizing memory access. They are significantly faster than calling get_code in a loop.\n\nThese functions exploit the fact that consecutive samples often map to the same code chip, avoiding per-sample floating-point operations and modulo calculations.\n\nusing GNSSSignals\nusing Unitful: Hz, kHz, MHz\n\ngpsl1 = GPSL1()\nprn = 1\nsampling_frequency = 4MHz\nnum_samples = 4000  # 1 ms at 4 MHz\n\n# Allocating version\nsampled_code = gen_code(num_samples, gpsl1, prn, sampling_frequency)\n\n# In-place version (more efficient for repeated calls)\nbuffer = zeros(Int16, num_samples)\ngen_code!(buffer, gpsl1, prn, sampling_frequency)","category":"section"},{"location":"usage/#With-Doppler-Shift","page":"Usage","title":"With Doppler Shift","text":"To generate code with a Doppler-shifted code frequency:\n\nusing GNSSSignals\nusing Unitful: Hz, MHz\n\ngpsl1 = GPSL1()\nprn = 1\nsampling_frequency = 4MHz\ncarrier_doppler = 1000Hz\n\n# Calculate code Doppler from carrier Doppler\ncode_doppler = carrier_doppler * get_code_center_frequency_ratio(gpsl1)\ncode_frequency = get_code_frequency(gpsl1) + code_doppler\n\n# Generate Doppler-shifted code\nsampled_code = gen_code(4000, gpsl1, prn, sampling_frequency, code_frequency)","category":"section"},{"location":"usage/#With-Phase-Offset","page":"Usage","title":"With Phase Offset","text":"You can specify a starting code phase:\n\nstart_phase = 100.5  # Start at chip 100.5\nprn = 1\nsampling_frequency = 4MHz\nsampled_code = gen_code(4000, gpsl1, prn, sampling_frequency, get_code_frequency(gpsl1), start_phase)","category":"section"},{"location":"usage/#Working-with-Different-GNSS-Systems","page":"Usage","title":"Working with Different GNSS Systems","text":"","category":"section"},{"location":"usage/#GPS-L1","page":"Usage","title":"GPS L1","text":"GPS L1 uses BPSK modulation with a 1023-chip C/A code:\n\ngpsl1 = GPSL1()\nget_code_length(gpsl1)           # 1023\nget_center_frequency(gpsl1)      # 1575420000 Hz\nget_code_frequency(gpsl1)        # 1023000 Hz\nget_secondary_code_length(gpsl1) # 1 (no secondary code)\nget_modulation(gpsl1)            # LOC()","category":"section"},{"location":"usage/#GPS-L5","page":"Usage","title":"GPS L5","text":"GPS L5 uses BPSK modulation with a 10230-chip code and 10-bit Neuman-Hofman secondary code:\n\ngpsl5 = GPSL5()\nget_code_length(gpsl5)           # 10230\nget_center_frequency(gpsl5)      # 1176450000 Hz\nget_code_frequency(gpsl5)        # 10230000 Hz\nget_secondary_code_length(gpsl5) # 10\nget_secondary_code(gpsl5)        # (1, 1, 1, 1, -1, -1, 1, -1, 1, -1)","category":"section"},{"location":"usage/#Galileo-E1B","page":"Usage","title":"Galileo E1B","text":"Galileo E1B uses CBOC(6,1,1/11) modulation:\n\ngal_e1b = GalileoE1B()\nget_code_length(gal_e1b)         # 4092\nget_center_frequency(gal_e1b)    # 1575420000 Hz\nget_code_frequency(gal_e1b)      # 1023000 Hz\nget_modulation(gal_e1b)          # CBOC(BOCsin(1,1), BOCsin(6,1), 10/11)\n\nNote that due to CBOC modulation, Galileo E1B code values are floating-point rather than integer.","category":"section"},{"location":"usage/#Basic-Code-Access","page":"Usage","title":"Basic Code Access","text":"For accessing individual code values at specific phases (e.g., for analysis or custom resampling), use get_code:\n\nusing GNSSSignals\n\ngpsl1 = GPSL1()\nprn = 1\n\n# Get a single code value at phase 0.0 for PRN = prn\ncode_value = get_code(gpsl1, 0.0, prn)  # Returns 1 or -1\n\n# Get a full code period using broadcasting\ncode_phases = 0:1022\nfull_code = get_code.(gpsl1, code_phases, prn)\n\nThe phase is specified in chips and automatically wraps around the code length.\n\nnote: Note\nPrefer gen_code or gen_code! for generating sampled codes at a specific sampling frequency, as they are significantly faster.","category":"section"},{"location":"usage/#Accessing-Raw-Codes","page":"Usage","title":"Accessing Raw Codes","text":"To get the full code matrix directly:\n\ngpsl1 = GPSL1()\ncodes = get_codes(gpsl1)  # Matrix of size (code_length, num_prns)\nsize(codes)               # (1023, 37)\n\nEach column represents a different PRN.","category":"section"},{"location":"usage/#Signal-Spectrum","page":"Usage","title":"Signal Spectrum","text":"To compute the power spectral density at a given frequency:\n\nusing GNSSSignals\nusing Unitful: kHz\n\ngpsl1 = GPSL1()\npsd = get_code_spectrum(gpsl1, 0kHz)  # PSD at DC\n\nFor custom spectrum calculations:\n\nusing GNSSSignals\nusing Unitful: MHz, kHz\n\n# BPSK spectrum\npsd_bpsk = GNSSSignals.get_code_spectrum_BPSK(1.023MHz, 500kHz)\n\n# BOC spectrum\npsd_boc = GNSSSignals.get_code_spectrum_BOCsin(1.023MHz, 1.023MHz, 500kHz)","category":"section"},{"location":"usage/#Performance-Tips","page":"Usage","title":"Performance Tips","text":"Use gen_code! instead of gen_code when generating codes repeatedly to avoid allocations.\nPre-allocate buffers for signal generation:\nnum_iterations = 1000\nbuffer = zeros(Int16, num_samples)\nfor i in 1:num_iterations\n    gen_code!(buffer, gpsl1, prn, sampling_frequency)\n    # process buffer...\nend","category":"section"},{"location":"#GNSSSignals.jl","page":"Home","title":"GNSSSignals.jl","text":"A Julia package for generating GNSS (Global Navigation Satellite System) spreading codes and signals.","category":"section"},{"location":"#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"#Supported-GNSS-Systems","page":"Home","title":"Supported GNSS Systems","text":"System Carrier Frequency Code Frequency Code Length Modulation\nGPS L1 1575.42 MHz 1.023 MHz 1023 chips BPSK\nGPS L5 1176.45 MHz 10.23 MHz 10230 chips BPSK + Neuman-Hofman\nGalileo E1B 1575.42 MHz 1.023 MHz 4092 chips CBOC(6,1,1/11)","category":"section"},{"location":"#Modulation-Types","page":"Home","title":"Modulation Types","text":"LOC - Legacy/BPSK modulation (GPS L1, GPS L5)\nBOCsin - Sine-phased Binary Offset Carrier\nBOCcos - Cosine-phased Binary Offset Carrier\nCBOC - Composite Binary Offset Carrier (Galileo E1B)","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"using Pkg\nPkg.add(\"GNSSSignals\")\n\nOr from the Julia REPL:\n\njulia> ]\npkg> add GNSSSignals","category":"section"},{"location":"#Quick-Start","page":"Home","title":"Quick Start","text":"For most applications, use gen_code or gen_code! to generate sampled codes. These functions are highly optimized and significantly faster than calling get_code in a loop.\n\nusing GNSSSignals\nusing Unitful: MHz\n\ngpsl1 = GPSL1()\nprn = 1\n\n# Generate 1 ms of sampled code at 4 MHz (recommended approach)\nsampled_code = gen_code(4000, gpsl1, prn, 4MHz)\n\n# For repeated calls, use the in-place version with a pre-allocated buffer\nbuffer = zeros(Int16, 4000)\ngen_code!(buffer, gpsl1, prn, 4MHz)\n\nFor accessing individual code values at specific phases, use get_code:\n\n# Get a single code value\ncode_value = get_code(gpsl1, 0.0, prn)  # Returns 1 or -1\n\n# Get a full code period (slower than gen_code for large arrays)\ncode_phases = 0:1022\nfull_code = get_code.(gpsl1, code_phases, prn)\n\nFor more detailed examples, see the Usage guide.","category":"section"},{"location":"#Package-Overview","page":"Home","title":"Package Overview","text":"GNSSSignals.jl provides functionality to:\n\nGenerate spreading codes for GPS L1, GPS L5, and Galileo E1B\nSample codes at arbitrary frequencies with gen_code and gen_code!\nAccess code values at specific phases with get_code\nQuery system parameters (code length, frequencies, modulation type)\nCompute signal spectra for analysis\n\nThe gen_code and gen_code! functions are highly optimized for real-time GNSS signal processing, using fixed-point arithmetic and minimizing memory access by exploiting the fact that consecutive samples often map to the same code chip.\n\nThe package is designed to be used as a building block for GNSS receiver implementations and signal processing research.","category":"section"}]
}
